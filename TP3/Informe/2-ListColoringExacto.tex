\newpage
\section{Problema 1: Algoritmo Exacto para 2-List Coloring}

\subsection{Descripción de la problemática}
Este ejericicio está centrado en la resolución de un problema particular de coloreo, 2-listColoring. En este caso, cada nodo se puede colorear solo con uno o dos colores específicos. El algoritmo debe determinar si existe o no un coloreo en donde no existen dos nodos consecutivos del mismo color y, en caso afirmativo, encontrar una solución.
Este problema es facilmente reducible a 2-SAT, por lo cual existen algortmos polinomiales que lo resuelven.

\subsection{Resolución propuesta y justificación}
Como mencionamos antes, el problema del 2-ListColoring es fácilmente reducible a un problema de 2-SAT, y en esto se basa el algoritmo implementado. Si existe una coloración posible, entonces el hecho de que un determinado nodo esté pintado de un color implica que ninguno de sus vecinos esta pintado del mismo. Además, si un nodo tiene dos colores posibles, el nodo esta pintado de un color C1 si y solo si no esta pintado del color C2.
El 2-SAT se representa con un grafo dirigido en donde un nodo A (que representa una proposición) apunta a un nodo B si A implica B.

Sean x, y, z proposiciones representadas por nodos de nuestro grafo dirigido, si en el grafo existe una arista desde el nodo que representa a x al nodo que representa a y, y otra arista entre el nodo que representa a y al nodo que representa a z, esto significa que x $\rightarrow$ y e y $\rightarrow$ z, de lo cual se deduce que x $\rightarrow$ z. Generalizando se puede decir que, dadas x, z proposiciones,  x $\rightarrow$ z si y solo si existe un camino desde el nodo que representa a x hasta el nodo que representa a z. Es decir, en este contexto una componente fuertemente conexa representa un conjunto de proposiciones de las cuales se puede afirmar que todas son válidas o todas son falsas. 

Para la resolución del 2-SAT, se implementa el algoritmo de Kosaraju. Este algoritmo recibe como entrada un grafo dirigido y devuelve como resultado las componentes fuertemente conexas que se encuentran en el mismo. 

Como el algoritmo de Kosaraju encuentra todas las componentes fuertemente conexas, entonces, dadas dos componentes C1 y C2, si existe un camino entre C1 y C2, no puede existir un camino desde C2 a C1 (de lo contrario ambas debería estar en la misma componente). Además, si existe un camino entre C1 y C2, con el algoritmo de Kosaraju C1 será detectada antes que C2. Nuestra implementación fue diseñada para que la lista de componentes fuertemente conexas resultante del algoritmo preserve este orden de detección. Posteriormente de la ejecución del Kosaraju, nuestro algoritmo registra, para cada componente conexa, cual es la componente conexa que contiene la negación de sus proposiciones. En caso de que una misma componente conexa contenga a una proposición y su negación, entonces se determina que el problema no tiene solución, ya que implicaría que, sea x la proposición en cuestión, x $\leftrightarrow$ $\lnot$x.

Finalmente comienzan a fijarse los valores de verdad, recorriendo las componentes fuertemente conexas en el orden en que fueron obtenidas en el paso anterior. Si a la componente aún no se le asignó un valor de verdad, se le asigna false. Cuando se fija un valor para una componente determinada, a la componente que contiene la negación de sus proposiciones se le asigna el valor opuesto.  Además, si a una componente se le asigna false, todos las componentes que implican a la misma (es decir, todas las componentes desde las cuales existe un camino hasta la componente evaluada) también se les asigna false (recursivamente). Y, si a una componente se le asigna true, a todas las componentes que son implicadas por la misma se  les asigna también true. Si el algoritmo encuentra una contradicción (es decir, una componente que a la que se busca  asignar false ya tiene true o viceversa), determina que el problema no tiene solución.

Una vez determinados los valores de verdad, se deduce la coloración de los nodos del grafo original a partir de las proposiciones que forman parte de las componentes evaluadas como verdaderas.

\begin{algorithmic} 
\newcommand{\INDSTATE}[1][1]{\STATE\hspace{#1\algorithmicindent}}
 \STATE{Algoritmo2ListColoring(grafo_original)}
	\INDSTATE[2]{GrafoDirigido = crearGrafoDirigidoConProposiciones(grafo_original)}
	\INDSTATE[2]{ListaComponentesConexas =  Kosaraju(GrafoDirigido)}
	\INDSTATE[2]{GrafoCompacto = generarGrafoCompacto(ListaComponentesConexas)
	\INDSTATE[4]{Si GrafoCompacto es INVALIDO}
		\INDSTATE[6]{Devolver NO_HAY_SOLUCION}

	\INDSTATE[4]{asignacionDeVerdad = AsignarValoresDeVerdad(ListaComponentesConexas,GrafoCompacto)}
	\INDSTATE[4]{Si asignacionDeVerdad==INVALIDO}
		\INDSTATE[6]{Devolver NO_HAY_SOLUCION}

	\INDSTATE[4]{Devolver ObtenerColoreoParaGrafoOriginal(ListaComponentesConexas)}
 \STATE Fin
\end{algorithmic} 

\begin{algorithmic}
\newcommand{\INDSTATE}[1][1]{\STATE\hspace{#1\algorithmicindent}}
\STATE crearGrafoDirigidoConProposiciones (grafo_original)
	\INDSTATE[2]{GrafoDirigido = vacio}
	\INDSTATE[2]{Para cada nodo del grafo_original}
		\INDSTATE[4]{Si cantidad_colores(nodo)==1}
			\INDSTATE[6]{GrafoDirigido.agregar(¬Acl -> Acl)}
		\INDSTATE[4]{Sino}
			\INDSTATE[6]{GrafoDirigido.agregar(Acl1 <-> ¬Acl2)}
			\INDSTATE[6]{GrafoDirigido.agregar(Acl2 <-> ¬Acl1)}
\STATE
	\INDSTATE[2]{Para cada arista (A,B)}
		\INDSTATE[4]{Para cada color comun c entre A y B}
			\INDSTATE[6]{GrafoDirigido.agregar(Ac -> ¬Bc)}
			\INDSTATE[6]{GrafoDirigido.agregar(Bc -> ¬Ac)}

	Devolver GrafoDirigido
\STATE Fin
\end{algorithmic} 

\begin{algorithmic}
\newcommand{\INDSTATE}[1][1]{\STATE\hspace{#1\algorithmicindent}}
\STATE Kosaraju(grafoDirigido)
	\INDSTATE[2]{ListaComponentesConexas = vacio}
	\INDSTATE[2]{Pila = vacio}
	\INDSTATE[2]{Para cada nodo A de grafoDirigido}
		\INDSTATE[4]{si (Pila.no_contiene(A))}
			\INDSTATE[6]{apilar nodos partiendo de A utilizando BFS}
		
	\INDSTATE[2]{grafoDirigidoInverso = grafoDirigido.invertir_aristas()}

	\INDSTATE[2]{Mientras Pila no vacia}
		\INDSTATE[4]{A = Pila.SacarPrimero}
		\INDSTATE[4]{Si (no_marcada(A))}
			\INDSTATE[6]{Componente = vacio}
			\INDSTATE[6]{agregar a Componente todos los nodos partiendo de A utilizando BFS en grafoDirigidoInverso}
			\INDSTATE[6]{marcar(A)}
			\INDSTATE[6]{ListaComponentesConexas.agrefarAlFinal(Componente)}
\STATE
	\INDSTATE[2]{Devolver ListaComponentesConexas}
\STATE Fin
\end{algorithmic}

\begin{algorithmic}
\newcommand{\INDSTATE}[1][1]{\STATE\hspace{#1\algorithmicindent}}
\STATE generarGrafoCompacto(ListaComponentesConexas)
	\INDSTATE[2]{GrafoCompacto = vacio}
	\INDSTATE[2]{Para cada componente en ListaComponentesConexas}
		\INDSTATE[4]{Para cada nodo A de componente}
			\INDSTATE[6]{Para cada arista (A,B)}
				\INDSTATE[8]{componente.agregarArista(componenteDe(B))}
			\INDSTATE[6]{Para cada nodo B negado por A}
				\INDSTATE[8]{componente.asociarComoNegacion(componenteDe(B))}
				\INDSTATE[8]{componenteDe(B).asociarComoNegacion(componente)}

				\INDSTATE[8]{Si componente==componenteDe(B)}
					\INDSTATE[10]{Devolver INVALIDO}

\STATE
	\INDSTATE[2]{Devolver GrafoCompacto}
\STATE Fin
\end{algorithmic}

\begin{algorithmic}
\newcommand{\INDSTATE}[1][1]{\STATE\hspace{#1\algorithmicindent}}
\STATE AsignarValoresDeVerdad(ListaComponentesConexas,GrafoCompacto)
	\INDSTATE[2]{Para cada componente ListaComponentesConexas}
		\INDSTATE[4]{Si no esta marcada componente}
			\INDSTATE[6]{marcar(componente,false)}
			\INDSTATE[6]{propagar false a todas las componentes que poseen un camino hasta esta componente en GrafoCompacto}
			\INDSTATE[6]{Si inconsistencia al propagar}
				\INDSTATE[8]{Devolver INVALIDO}

			\INDSTATE[6]{marcar(componente.negacionAsociada,true)}
			\INDSTATE[6]{propagar true a todas las componentes accesibles desde componente.negacionAsociada en GrafoCompacto}
			\INDSTATE[6]{Si inconsistencia al propagar}
				\INDSTATE[8]{Devolver INVALIDO}
\STATE
	\INDSTATE[2]{Devolver VALIDO}

\STATE Fin
\end{algorithmic}

\begin{algorithmic}
\newcommand{\INDSTATE}[1][1]{\STATE\hspace{#1\algorithmicindent}}
\STATE ObtenerColoreoParaGrafoOriginal(ListaComponentesConexas)
	\INDSTATE[2]{Colores = vacio}
	\INDSTATE[2]{Para cada componente con valor true en ListaComponentesConexas}
		\INDSTATE[4]{Para cada nodo con proposicion afirmativa de componente}
			\INDSTATE[6]{Colores.asignar_color(nodo.nodoDeGrafoOriginal.identidad,nodo.colorPropuesto)}
	\INDSTATE[2]{Devolver Colores}
\STATE Fin
\end{algorithmic}


\subsection{Análisis de la complejidad}
El grafo dirigido contiene a los sumo cuatro veces más nodos que el grafo de entrada, y el grafo compacto tiene a los sumo tantos nodos como el grafo dirigido. Por lo tanto, podemos afirmar que, sea n la cantidad de nodos inicial, n' la cantidad de nodos del grafo dirigido y n'' la cantidad de nodos del grafo compacto, $\mathcal{O}(f(n)) = \mathcal{O}(f(n')) = \mathcal{O}(f(n''))$ (si no se conocen datos adicionales para la entrada).

Generar el grafo dirigido a partir del grafo de entrada tiene una complejidad de $\mathcal{O}(n^2\log{n})$, ya que para cada nodo del grafo, es necesario crear los nodos dirigidos que lo representan y definir sus aristas con otros nodos. A medida que se van creando, los nodos se guardan y se buscan en un TreeSet.

El algoritmo utilizado para encontrar las componentes fuertemente conexas no recorre más de dos veces todos los nodos, por lo cual su complejidad es lineal, al igual que el algoritmo que determina el valor de verdad de los nodos compactos.

\subsection{Experimentación}
Casos de test:
\subsubsection{El triángulo}
En este test existen tres nodos interconextados en donde cada nodo comparte un color con uno de sus vecinos. El algoritmo debería encontrar la única solución posible.
Posteriormente, se le añade al triangulo un nodo extra vecino del primero con el color con el cual estaba pintado el primero, con lo cual no existe solución.
\subsubsection{El pentagono}
En esta oportunidad, se dibuja un k5. Cada nodo tiene como opción un color que no se repite en sus compañeros y otro que es compartido por más de uno. El algoritmo debería encontrar una solución
\subsubsection{El señor de los anillos}
En este caso se prueba un ciclo de seis nodos. A los pares se les asigna 0 y a los impares uno, y además todos poseen un segundo color que comparten con uno de sus vecinos. Como el grafo es bipartito, el algoritmo debería hallar una solución.
\subsubsection{Grafos bipartitos completos}
Otro de los casos se basa en generar grafos bipartitos completos. En este caso, se les asigna a todos los nodos 0 y 1. Como un grafo bipartito (en particular, uno completo) puede colorearse con dos colores, el algoritmo deberia encontrar una solución para el mismo. Posteriormente, se le añade al grafico una arista que une dos nodos que no estaban conectados, con lo que el grafo deja de ser bipartito y se necesitan 3 colores para colorearlo. En este caso, el algoritmo debería determinar que no existe solución.

\subsubsection{Testeos de complejidad}
Para testear la complejidad, se generan grafos al azar en donde todos los nodos poseen como opciones de coloreo a un color que no se repite en los demás nodos y otro que es seleccionado al azar. En una de las estrrategias se deja fija la cantidad de aristas, en otra se fija la cantidad de nodos, y en la otro se incrementan las aristas y los nodos en igual proporción.

\subsubsection{Complejidad en grafos completos}
En un último caso se generan grafos completos en donde se a incrementando la cantidad de nodos (y, logicamente, de aristas). Debido al consumo de memoria, este último caso se ha testeado con valores inferiores que al resto de los test.

% \subsubsection{Constrastación Empírica de la complejidad}


% \begin{figure}[H]
% 	\centering
%  	\includegraphics[scale=0.6]{imagenes/ej3/tiempos1000B.png}
% 	\caption{Medición de tiempo promedio con $n$ fijo en 1000}
% 	%\label{tiemposprom}
%  \end{figure}