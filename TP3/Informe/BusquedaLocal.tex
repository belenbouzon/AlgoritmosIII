\section{Problema 4: Heurística de búsqueda local}

\subsection{Descripción del algoritmo}

Después de aplicar la heurística de búsqueda golosa sobre el problema obtenemos un grafo en el que puede haber conflictos. Esta segunda heurística que desarrollamos se aplica sobre instancias del problema donde ya hay un color válido asignado a todos los nodos. Se trata, entonces, de reducir la cantidad de conflictos de la instancia.

La heurística de búsqueda local define una "vecindad" del problema que se define como una modificación 

EXPLICAR VECINDADES

\subsubsection{Vecindad 1}

Esta vecindad toma una arista en conflicto\footnote{Es decir que ambos nodos de la arista tienen el mismo color.} e intenta modificar el color de uno de los dos nodos, tratando de reducir la cantidad total de conflictos.

A partir de una arista que representa un conflicto (llamemos a los nodos de la arista N1 y N2):
\begin{enumerate}
 \item crear un diccionario para ambos nodos. El diccionario tendrá como key a los colores del nodo, y como valor una lista de vecinos del nodo que tienen asignado ese color. LLamaremos a estos diccionarios \texttt{conflictosPorColorN1} y \texttt{conflictosPorColorN2}.
 \item tanto para N1 como para N2, iteramos sobre su lista de colores posibles y llenamos los diccionarios conflictosPorColorN1 y conflictosPorColorN2 de manera tal que para cada color posible de ambos nodos, tenemos una lista vacía de vecinos
 \item Luego iteramos la lista de vecinos de N1. Si el color del vecino es uno de los colores posibles de N1, agregaremos este vecino a la lista de conflictosPorColorN1[color_del_vecino].
 \item Hacemos lo mismo para los vecinos de N2.
 \item Ahora buscamos dentro de conflictosPorColorN1 al color que genera menos conflictos (su lista es la más corta)
 \item Hacemos lo mismo para conflictosPorColorN2.
 \item De esos dos elegimos al menor. Si la cantidad de conflictos es menor a la que se tiene dejando todo como está, cambiamos el color del nodo. Si no, la vecindad no sirvió y no hacemos modificaciones en el grafo.
\end{enumerate}

\begin{algorithm}[H]
\caption{Vecindad 1.}
\label{vecindad1 pseudocode}
\begin{algorithmic}[1] 
\STATE La vecindad opera sobre una arista que recibe como parámetro. Llamaremos a esta arista $conflicto$. Los dos nodos unidos por esta arista serán $conflicto$.n1 y $conflicto$.n2.
\REQUIRE $conflicto$.n1.getColor() == $conflicto$.n2.getColor()
\STATE crear un diccionario para ambos nodos. El diccionario tendrá como key a los colores del nodo, y como valor una lista de vecinos del nodo que tienen asignado ese color. Llamaremos a estos diccionarios $conflictosPorColorN1$ y $conflictosPorColorN2$. Inicializamos esos diccionarios con una lista vacía para cada color:
\FOR{color in $conflicto$.n1.get_coloresPosibles}
    \STATE $conflictosPorColorN1$[color] = Lista vacía de nodos;
\ENDFOR
\FOR{color in $conflicto$.n2.get_coloresPosibles}
    \STATE $conflictosPorColorN2$[color] = Lista vacía de nodos;
\ENDFOR

\STATE Recorremos la lista de vecinos de los dos nodos de $conflicto$. Si un vecino está pintado con alguno de los colores posibles del nodo en conflicto, lo agregamos a la lista correspondiente.
\FOR{vecino in $conflicto$.n1.vecinos}
    \IF{vecino.color definido en $conflictosPorColorN1$}
	\STATE $conflictosPorColorN1$[vecino.color].agregar(vecino)
    \ENDIF
\ENDFOR
\FOR{vecino in $conflicto$.n2.vecinos}
    \IF{vecino.color definido en $conflictosPorColorN1$}
	\STATE $conflictosPorColorN2$[vecino.color].agregar(vecino)
    \ENDIF
\ENDFOR

\STATE para $conflictosPorColorN1$ y $conflictosPorColorN2$ buscamos el mínimo: es decir, aquel color que tiene como valor la lista más corta. Y entre el menor de n1 y n2, elegimos al menor.

\STATE 




\STATE Retornar
\end{algorithmic}
\end{algorithm}
\leavevmode


 
% 		 * 1. obtener conjunto de colores posibles para Nodo n1
% 		 * 2. crear HashTable<int, int> conflictosPorColor (inicializar en 0) 
% 		 * 3. para cada v en vecinos de n1
% 		 *     3.1. conflictosPorColor[v.getColor()] += 1
% 		 * hacer lo mismo para Nodo n2
% 		 */


% 		Hashtable<Integer, ArrayList<NodoConVecinos>> conflictosPorColorN1 = new Hashtable<Integer, ArrayList<NodoConVecinos>>();  // O(1)
% 		Hashtable<Integer, ArrayList<NodoConVecinos>> conflictosPorColorN2 = new Hashtable<Integer, ArrayList<NodoConVecinos>>();	// O(1)
% 		for (int color: target.getN1().get_coloresPosibles()){						// O(c)
% 			ArrayList<NodoConVecinos> vacia = new ArrayList<NodoConVecinos>();
% 			conflictosPorColorN1.put(color, vacia);
% 		}
% 		for (int color: target.getN2().get_coloresPosibles()){						// O(c)
% 			ArrayList<NodoConVecinos> vacia = new ArrayList<NodoConVecinos>();
% 			conflictosPorColorN2.put(color, vacia);
% 		}
% 		
% 		for (NodoConVecinos v: target.getN1().vecinos()){							// O(n)
% 			if (conflictosPorColorN1.containsKey(v.getColor())){
% 				ArrayList<NodoConVecinos> nuevovalor = conflictosPorColorN1.get(v.getColor());
% 				nuevovalor.add(v);
% 				conflictosPorColorN1.put(v.getColor(), nuevovalor);
% 			}
% 		}
% 		for (NodoConVecinos v: target.getN2().vecinos()){							// O(n)
% 			if (conflictosPorColorN2.containsKey(v.getColor())){
% 				ArrayList<NodoConVecinos> nuevovalor = conflictosPorColorN2.get(v.getColor());
% 				nuevovalor.add(v);
% 				conflictosPorColorN2.put(v.getColor(), nuevovalor);
% 			}
% 		}
% 		
% 		Integer candidatoN1 = minimo(conflictosPorColorN1);							// O(c)
% 		Integer candidatoN2 = minimo(conflictosPorColorN2);							// O(c)
% 		
% 		if (conflictosPorColorN1.get(candidatoN1).size() <= conflictosPorColorN2.get(candidatoN2).size()){	// O(1)
% 			return this.cambiarColor(candidatoN1, conflictosPorColorN1, target.getN1());
% 		} else{
% 			return this.cambiarColor(candidatoN2, conflictosPorColorN2, target.getN2());
% 		}
\subsubsection{Vecindad 2}

\subsection{Análisis de complejidad}






\subsection{Experimentación}


\subsubsection{Peor caso}



\subsubsection{Mejor caso}
